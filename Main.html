<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Loading Example Page</title>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      font-family: sans-serif;
      overflow: hidden; /* Prevent scrollbars during animation */
    }

    #loader {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: #f0f0f0; /* Light gray background */
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      flex-direction: column; /* Align items vertically for text + animation */
    }

    .loader-text {
      font-size: 1.5rem;
      font-weight: bold;
      color: #333;
      margin-bottom: 20px;
    }

    #animation-container {
      width: 200px;
      height: 150px;
      position: relative;
      /* border: 1px solid #ccc; */ /* For debugging */
    }

    .herb-svg-container { /* New container for SVG herbs */
      position: absolute;
      width: 15px; /* Adjust as needed based on SVG viewbox */
      height: 15px; /* Adjust as needed */
      opacity: 0;
      /* background-color: rgba(255,0,0,0.2); /* For debugging visibility */
    }

    .herb-svg-container svg {
      width: 100%;
      height: 100%;
      display: block;
    }

    #rolling-paper {
      position: absolute;
      width: 100px;
      height: 60px;
      background-color: white;
      border: 1px solid #ddd;
      bottom: 10px; /* Positioned at the bottom of the container */
      left: 50%;
      transform: translateX(-50%);
      opacity: 0;
      border-radius: 2px;
    }

    #joint {
      position: absolute;
      width: 80px; /* Slightly narrower than paper */
      height: 15px; /* Rolled up */
      background-color: white;
      border: 1px solid #ccc;
      bottom: 30px; /* Positioned where rolling would finish */
      left: 50%;
      transform: translateX(-50%);
      opacity: 0;
      border-radius: 7.5px; /* Make it cylindrical */
    }

    /* Animations */
    /* @keyframes fall is removed - will be handled by JavaScript */
    /* @keyframes gatherHerbs is removed - will be handled by JavaScript */

    @keyframes paperAppear {
      from { opacity: 0; transform: translateX(-50%) translateY(20px) scale(0.7); } /* Appear from slightly below and smaller */
      to { opacity: 1; transform: translateX(-50%) translateY(0px) scale(1); }
    }

    @keyframes rollJointPaperHide {
      0% { opacity: 1; height: 60px; }
      100% { opacity: 0; height: 15px; } /* Shrink paper as joint forms */
    }

    @keyframes rollJointAppear {
      0% { opacity: 0; width: 70px; height: 10px; transform: translateX(-50%) translateY(10px); } /* Start smaller, slightly lower */
      100% { opacity: 1; width: 80px; height: 15px; transform: translateX(-50%) translateY(0px); } /* Grow to final size */
    }

    @keyframes jointFlourish {
        0% { transform: translateX(-50%) translateY(0px) rotate(0deg); }
        30% { transform: translateX(-50%) translateY(-15px) rotate(-8deg); } /* Higher, more rotation */
        70% { transform: translateX(-50%) translateY(5px) rotate(3deg); } /* Overshoot downwards */
        100% { transform: translateX(-50%) translateY(0px) rotate(0deg); }
    }


    #content {
      display: none;
      padding: 2rem;
      text-align: center;
    }
  </style>
</head>
<body>

  <!-- Loader -->
  <div id="loader">
    <div class="loader-text">Preparing your experience...</div>
    <div id="animation-container">
      <!-- Herbs will be added here by JS -->
      <div id="rolling-paper"></div>
      <div id="joint"></div>
    </div>
  </div>

  <!-- Page Content -->
  <div id="content">
    <h1>Welcome to the Page!</h1>
    <p>This page was displayed after a simulated load delay.</p>
  </div>

  <script>
    window.addEventListener('load', () => {
      const loader = document.getElementById('loader');
      const content = document.getElementById('content');
      const animationContainer = document.getElementById('animation-container');
      const paper = document.getElementById('rolling-paper');
      const joint = document.getElementById('joint');

      // --- Asset Definitions ---
      const herbSVGData = [
        // Simple leaf shape 1
        '<svg viewBox="0 0 20 20"><path fill="#4CAF50" d="M10 0 C5 5, 5 15, 10 20 C15 15, 15 5, 10 0 Z"></path></svg>',
        // Simple leaf shape 2 (slightly different)
        '<svg viewBox="0 0 20 20"><path fill="#388E3C" d="M10 0 Q5 10, 10 20 Q15 10, 10 0 Z"></path></svg>',
        // Simple leaf shape 3 (more elongated)
        '<svg viewBox="0 0 20 20"><path fill="#558B2F" d="M10 0 C7 7, 7 13, 10 20 C13 13, 13 7, 10 0 Z"></path></svg>'
      ];

      // --- Animation Parameters ---
      const NUM_HERBS = 25; // Increased number of herbs
      const PAPER_APPEAR_DELAY = 600; // ms - When paper starts to appear after load
      const PAPER_APPEAR_DURATION = 600; // ms
      const GATHER_HERBS_DELAY = 1800; // ms - When herbs start to gather (after falling)
      const GATHER_HERBS_DURATION = 900; // ms
      const ROLL_JOINT_HIDE_DURATION = 700; // ms (paper hiding)
      const ROLL_JOINT_APPEAR_DURATION = 800; // ms (joint appearing)
      const JOINT_FLOURISH_DURATION = 600; //ms
      const JOINT_FLOURISH_REPEATS = 2;

      const herbs = []; // Array to store herb objects with their properties

      // Physics constants
      const GRAVITY = 0.08; // Acceleration due to gravity (pixels per frame^2)
      const DRAG_COEFFICIENT = 0.01; // Air resistance
      const GROUND_Y = animationContainer.clientHeight - 30; // Y-coordinate of the paper surface, adjusted for herb size
      const LATERAL_SPREAD = 180; // Max horizontal spread for falling herbs

      // 1. Create Herbs (as JS objects)
      for (let i = 0; i < NUM_HERBS; i++) {
        const herbElement = document.createElement('div');
        herbElement.classList.add('herb-svg-container');
        herbElement.innerHTML = herbSVGData[i % herbSVGData.length]; // Cycle through SVG shapes
        animationContainer.appendChild(herbElement);

        herbs.push({
          element: herbElement,
          x: Math.random() * LATERAL_SPREAD + (animationContainer.clientWidth - LATERAL_SPREAD) / 2, // Start near center
          y: -Math.random() * 100 - 15, // Start above the screen, 15 is approx herb height
          vy: Math.random() * 2 + 1,  // Initial downward velocity
          vx: (Math.random() - 0.5) * 2, // Initial horizontal velocity (slight drift)
          rotation: Math.random() * 360,
          rotationSpeed: (Math.random() - 0.5) * 4, // Degrees per frame
          landed: false,
          targetGatherX: animationContainer.clientWidth / 2, // Center of paper
          targetGatherY: GROUND_Y - 5, // Slightly above ground
          gathering: false,
          gathered: false,
          opacity: 0, // Start invisible
          appearDelay: Math.random() * 1000 // Staggered appearance
        });
        herbElement.style.transform = `translate(${herbs[i].x}px, ${herbs[i].y}px) rotate(${herbs[i].rotation}deg)`;
        herbElement.style.position = 'absolute'; // Ensure absolute positioning is set
      }

      let animationStartTime = null;

      function animateHerbs(timestamp) {
        if (!animationStartTime) animationStartTime = timestamp;
        const elapsedTime = timestamp - animationStartTime;

        herbs.forEach(herb => {
          if (herb.gathered) return;

          // Appearance
          if (!herb.opacity && elapsedTime > herb.appearDelay) {
            herb.opacity = 1;
            herb.element.style.opacity = 1;
          }
          if (!herb.opacity) return; // Don't animate if not yet appeared

          if (!herb.landed) {
            // Apply gravity
            herb.vy += GRAVITY;
            // Apply basic air resistance (drag)
            herb.vy *= (1 - DRAG_COEFFICIENT);
            herb.vx *= (1 - DRAG_COEFFICIENT);

            herb.y += herb.vy;
            herb.x += herb.vx;
            herb.rotation += herb.rotationSpeed;

            // Check for landing
            if (herb.y >= GROUND_Y) {
              herb.y = GROUND_Y;
              herb.vy = 0; // Stop vertical motion (can add bounce here later)
              herb.vx = 0; // Stop horizontal drift on landing
              herb.rotationSpeed = 0; // Stop rotation
              herb.landed = true;
            }
          } else if (herb.gathering && !herb.gathered) {
            // Move towards gather point
            const dx = herb.targetGatherX - herb.x;
            const dy = herb.targetGatherY - herb.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist < 5) { // Close enough
              herb.gathered = true;
              herb.element.style.opacity = 0; // Fade out when gathered
            } else {
              herb.x += dx * 0.1; // Move 10% of the distance per frame
              herb.y += dy * 0.1;
            }
          }
          herb.element.style.transform = `translate(${herb.x}px, ${herb.y}px) rotate(${herb.rotation}deg)`;
        });

        // Continue animation as long as not all herbs are gathered or if other animations are running
        if (herbs.some(h => !h.gathered) || elapsedTime < (GATHER_HERBS_DELAY + GATHER_HERBS_DURATION + 2000 /*buffer for other anims*/)) {
          requestAnimationFrame(animateHerbs);
        }
      }

      requestAnimationFrame(animateHerbs); // Start the herb animation loop

      // 2. Paper appears
      setTimeout(() => {
        paper.style.animation = `paperAppear ${PAPER_APPEAR_DURATION / 1000}s cubic-bezier(0.25, 0.1, 0.25, 1.5) forwards`;
      }, PAPER_APPEAR_DELAY);

      // 3. Gather herbs (trigger gathering state for JS animation)
      setTimeout(() => {
        herbs.forEach(herb => {
          if (herb.landed) { // Only gather landed herbs
            herb.gathering = true;
          } else { // If not landed yet, mark as gathered to remove them
            herb.gathered = true;
            herb.element.style.opacity = 0;
          }
        });
      }, GATHER_HERBS_DELAY);

      // 4. Roll joint (paper hides, joint appears)
      const rollStartTime = GATHER_HERBS_DELAY + GATHER_HERBS_DURATION * 0.6; // Start rolling as herbs are still gathering
      setTimeout(() => {
        paper.style.animation = `rollJointPaperHide ${ROLL_JOINT_HIDE_DURATION / 1000}s ease-in forwards`;

        joint.style.animation = `rollJointAppear ${ROLL_JOINT_APPEAR_DURATION / 1000}s ease-out forwards`;
        // Joint appears slightly after paper starts to hide, creating an overlap for smoother transition
        joint.style.animationDelay = `${ROLL_JOINT_HIDE_DURATION * 0.25 / 1000}s`;

      }, rollStartTime);

      // 5. Joint flourish
      // Ensure flourish starts after the joint has fully appeared.
      const flourishStartTime = rollStartTime + ROLL_JOINT_HIDE_DURATION * 0.25 + ROLL_JOINT_APPEAR_DURATION;
      setTimeout(() => {
        // Using 'forwards' for rollJointAppear to ensure it holds its state, then adding flourish
        // The jointFlourish animation is set to alternate and repeat.
        joint.style.animation = `rollJointAppear ${ROLL_JOINT_APPEAR_DURATION / 1000}s ease-out forwards, jointFlourish ${JOINT_FLOURISH_DURATION / 1000}s cubic-bezier(0.68, -0.6, 0.32, 1.6) ${JOINT_FLOURISH_REPEATS} alternate forwards`;
        // The delay for jointFlourish is implicitly handled by its position in the animation string if rollJointAppear finishes first.
        // However, to be explicit and ensure rollJointAppear has finished, this timeout is set.
      }, flourishStartTime);


      // Total animation time before showing content
      // Calculated based on the sequence and overlaps, adding a final buffer
      const totalSimulatedLoadTime = flourishStartTime + (JOINT_FLOURISH_DURATION * JOINT_FLOURISH_REPEATS) + 400; // 400ms buffer

      setTimeout(() => {
        loader.style.display = 'none';
        content.style.display = 'block';
      }, totalSimulatedLoadTime);
    });
  </script>
</body>
</html>
