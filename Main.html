<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Loading Example Page</title>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      font-family: sans-serif;
      overflow: hidden; /* Prevent scrollbars during animation */
    }

    #loader {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: #f0f0f0; /* Light gray background */
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      flex-direction: column; /* Align items vertically for text + animation */
    }

    .loader-text {
      font-size: 1.5rem;
      font-weight: bold;
      color: #333;
      margin-bottom: 20px;
    }

    #animation-container {
      width: 200px;
      height: 150px;
      position: relative;
      /* border: 1px solid #ccc; */ /* For debugging */
    }

    .herb-svg-container { /* New container for SVG herbs */
      position: absolute;
      width: 15px; /* Adjust as needed based on SVG viewbox */
      height: 15px; /* Adjust as needed */
      opacity: 0;
      /* background-color: rgba(255,0,0,0.2); /* For debugging visibility */
    }

    .herb-svg-container svg {
      width: 100%;
      height: 100%;
      display: block;
    }

    #rolling-paper {
      position: absolute;
      width: 100px;
      height: 60px;
      background-color: white;
      border: 1px solid #ddd;
      bottom: 10px; /* Positioned at the bottom of the container */
      left: 50%;
      transform: translateX(-50%);
      opacity: 0;
      border-radius: 2px;
    }

    #joint {
      position: absolute;
      width: 80px; /* SVG viewBox width */
      height: 20px; /* SVG viewBox height */
      /* background-color: rgba(0,255,0,0.2); /* For debugging placement */
      /* border: none; Remove border if SVG is self-contained */
      bottom: 28px; /* Adjusted for new height and visual center */
      left: 50%;
      transform: translateX(-50%);
      opacity: 0;
      /* border-radius: 0; /* Not needed for SVG */
    }

    #joint svg { /* Ensure SVG scales within the container */
      width: 100%;
      height: 100%;
      display: block;
    }

    #tongue {
      position: absolute;
      width: 30px; /* SVG viewBox width */
      height: 40px; /* SVG viewBox height */
      opacity: 0;
      z-index: 5; /* Above paper, below herbs if they were to overlap during lick */
      left: 50%; /* Initial position, will be animated */
      bottom: 50px; /* Initial position, will be animated */
      transform: translateX(-50%) rotate(0deg) scale(0.5); /* Start smaller and centered */
      transform-origin: bottom center;
    }

    #tongue svg {
      width: 100%;
      height: 100%;
      display: block;
    }

    /* Animations */
    /* @keyframes fall is removed - will be handled by JavaScript */
    /* @keyframes gatherHerbs is removed - will be handled by JavaScript */

    @keyframes paperAppear {
      from { opacity: 0; transform: translateX(-50%) translateY(20px) scale(0.7); } /* Appear from slightly below and smaller */
      to { opacity: 1; transform: translateX(-50%) translateY(0px) scale(1); }
    }

    @keyframes rollJointPaperHide {
      0% {
        opacity: 1;
        width: 100px; /* Initial width of paper */
        height: 60px;
        transform: translateX(-50%) skewX(0deg);
        transform-origin: center;
      }
      50% {
        opacity: 0.7;
        width: 40px; /* Paper narrows significantly */
        height: 55px; /* Slight height reduction */
        transform: translateX(-25%) skewX(-15deg); /* Move to one side and skew */
        transform-origin: left center; /* Skew from left */
      }
      100% {
        opacity: 0;
        width: 10px; /* Almost disappears */
        height: 20px; /* Matches joint height for smoother transition */
        transform: translateX(0%) skewX(-30deg);
        transform-origin: left center;
      }
    }

    @keyframes rollJointAppear { /* Will be used for the SVG container */
      0% { opacity: 0; transform: translateX(-50%) scale(0.6) translateY(15px); } /* Start smaller, slightly lower, and scaled */
      100% { opacity: 1; transform: translateX(-50%) scale(1) translateY(0px); } /* Grow to final size and position */
    }

    @keyframes jointFlourish {
        0% { transform: translateX(-50%) translateY(0px) rotate(0deg); }
        30% { transform: translateX(-50%) translateY(-15px) rotate(-8deg); } /* Higher, more rotation */
        70% { transform: translateX(-50%) translateY(5px) rotate(3deg); } /* Overshoot downwards */
        100% { transform: translateX(-50%) translateY(0px) rotate(0deg); }
    }

    @keyframes lickPaper {
      0% { /* Initial state set by JS */
        opacity: 0;
        transform: translateX(-50%) translateY(30px) rotate(-30deg) scale(0.5); /* Start below, rotated, small */
      }
      20% { /* Appear and move to start of lick */
        opacity: 1;
        transform: translateX(-80px) translateY(0px) rotate(15deg) scale(1); /* Position left of paper edge */
      }
      30% { /* First part of lick */
        transform: translateX(-40px) translateY(-5px) rotate(5deg) scale(1.05);
      }
      60% { /* Lick across */
        transform: translateX(20px) translateY(-5px) rotate(-5deg) scale(1.05);
      }
      80% { /* Retract a bit */
        opacity: 1;
        transform: translateX(0px) translateY(10px) rotate(-20deg) scale(0.8);
      }
      100% { /* Disappear */
        opacity: 0;
        transform: translateX(-10px) translateY(40px) rotate(-40deg) scale(0.4);
      }
    }


    #content {
      display: none;
      padding: 2rem;
      text-align: center;
    }
  </style>
</head>
<body>

  <!-- Loader -->
  <div id="loader">
    <div class="loader-text">Preparing your experience...</div>
    <div id="animation-container">
      <!-- Herbs will be added here by JS -->
      <div id="rolling-paper"></div>
      <div id="tongue"></div> <!-- Tongue element added -->
      <div id="joint"></div>
    </div>
  </div>

  <!-- Page Content -->
  <div id="content">
    <h1>Welcome to the Page!</h1>
    <p>This page was displayed after a simulated load delay.</p>
  </div>

  <script>
    window.addEventListener('load', () => {
      const loader = document.getElementById('loader');
      const content = document.getElementById('content');
      const animationContainer = document.getElementById('animation-container');
      const paper = document.getElementById('rolling-paper');
      const joint = document.getElementById('joint');
      const tongue = document.getElementById('tongue'); // Get tongue element

      // --- Asset Definitions ---
      const herbSVGData = [
        // Simple leaf shape 1
        '<svg viewBox="0 0 20 20"><path fill="#4CAF50" d="M10 0 C5 5, 5 15, 10 20 C15 15, 15 5, 10 0 Z"></path></svg>',
        // Simple leaf shape 2 (slightly different)
        '<svg viewBox="0 0 20 20"><path fill="#388E3C" d="M10 0 Q5 10, 10 20 Q15 10, 10 0 Z"></path></svg>',
        // Simple leaf shape 3 (more elongated)
        '<svg viewBox="0 0 20 20"><path fill="#558B2F" d="M10 0 C7 7, 7 13, 10 20 C13 13, 13 7, 10 0 Z"></path></svg>'
      ];

      const jointSVGData = `
        <svg viewBox="0 0 80 20">
          <!-- Main joint body (cone shape) -->
          <defs>
            <linearGradient id="jointGradient" x1="0%" y1="0%" x2="100%" y2="0%">
              <stop offset="0%" style="stop-color:#fdfdfd;stop-opacity:1" />
              <stop offset="15%" style="stop-color:#f8f8f8;stop-opacity:1" />
              <stop offset="85%" style="stop-color:#f0f0f0;stop-opacity:1" />
              <stop offset="100%" style="stop-color:#e8e8e8;stop-opacity:1" />
            </linearGradient>
            <filter id="slightShadow" x="-20%" y="-20%" width="140%" height="140%">
              <feGaussianBlur in="SourceAlpha" stdDeviation="0.5"/>
              <feOffset dx="0.5" dy="0.5" result="offsetblur"/>
              <feComponentTransfer>
                <feFuncA type="linear" slope="0.3"/>
              </feComponentTransfer>
              <feMerge>
                <feMergeNode/>
                <feMergeNode in="SourceGraphic"/>
              </feMerge>
            </filter>
          </defs>
          <path d="M0 2 Q5 0, 15 1 L65 5 Q75 7, 80 10 Q75 13, 65 15 L15 19 Q5 20, 0 18 Z" fill="url(#jointGradient)" filter="url(#slightShadow)" />
          <!-- Twist lines -->
          <path d="M10 2.5 Q20 4, 30 5.5 L32 14.5 Q22 16, 12 17.5 Z" fill="rgba(0,0,0,0.04)" />
          <path d="M35 5 Q45 6, 55 7 L57 13 Q47 14, 37 15 Z" fill="rgba(0,0,0,0.04)" />
          <path d="M60 6.5 Q65 7.5, 70 8.5 L71 11.5 Q66 12.5, 61 13.5 Z" fill="rgba(0,0,0,0.03)" />
          <!-- Filter end (optional, can be a different color or just implied) -->
          <path d="M0 2 Q3 2.5, 5 3 L5 17 Q3 17.5, 0 18 Z" fill="#E0C0A0" /> <!-- Light brown for filter -->
        </svg>
      `;

      const tongueSVGData = `
        <svg viewBox="0 0 30 40">
          <defs>
            <linearGradient id="tongueGradient" x1="50%" y1="0%" x2="50%" y2="100%">
              <stop offset="0%" style="stop-color:#FF8A80; stop-opacity:1" /> <!-- Lighter pink -->
              <stop offset="100%" style="stop-color:#FF5252; stop-opacity:1" /> <!-- Deeper pink -->
            </linearGradient>
            <filter id="tongueShadow" x="-30%" y="-30%" width="160%" height="160%">
              <feGaussianBlur in="SourceAlpha" stdDeviation="1"/>
              <feOffset dx="1" dy="2" result="offsetblur"/>
              <feComponentTransfer>
                <feFuncA type="linear" slope="0.4"/>
              </feComponentTransfer>
              <feMerge>
                <feMergeNode/>
                <feMergeNode in="SourceGraphic"/>
              </feMerge>
            </filter>
          </defs>
          <path d="M0 10 Q5 0, 15 0 Q25 0, 30 10 L25 30 Q15 40, 5 30 Z" fill="url(#tongueGradient)" filter="url(#tongueShadow)" />
          <path d="M13 5 Q15 30, 17 5 Z" fill="rgba(255,255,255,0.2)" /> <!-- Highlight line -->
        </svg>
      `;

      // --- Animation Parameters ---
      const NUM_HERBS = 35; // Increased number of herbs as per new plan
      const PAPER_APPEAR_DELAY = 600; // ms - When paper starts to appear after load
      const PAPER_APPEAR_DURATION = 600; // ms
      const GATHER_HERBS_DELAY = 2200; // ms - Adjusted due to potentially longer fall times with flutter
      const GATHER_HERBS_DURATION = 1000; // ms - Slightly longer gather time
      const ROLL_JOINT_HIDE_DURATION = 700; // ms (paper hiding)
      const ROLL_JOINT_APPEAR_DURATION = 800; // ms (joint appearing)
      const JOINT_FLOURISH_DURATION = 600; //ms
      const JOINT_FLOURISH_REPEATS = 2;
      const TONGUE_LICK_ANIMATION_DURATION = 1500; // ms - Duration for the lickPaper CSS animation

      const herbs = []; // Array to store herb objects with their properties

      // Physics constants
      const GRAVITY = 0.08; // Acceleration due to gravity (pixels per frame^2)
      const DRAG_COEFFICIENT = 0.01; // Air resistance
      // GROUND_Y will now be dynamic based on paper's position
      const LATERAL_SPREAD = 180; // Max horizontal spread for falling herbs
      let paperRect; // To store paper dimensions and position

      // 1. Create Herbs (as JS objects)
      for (let i = 0; i < NUM_HERBS; i++) {
        const herbElement = document.createElement('div');
        herbElement.classList.add('herb-svg-container');
        herbElement.innerHTML = herbSVGData[i % herbSVGData.length]; // Cycle through SVG shapes
        animationContainer.appendChild(herbElement);

        herbs.push({
          element: herbElement,
          x: Math.random() * LATERAL_SPREAD + (animationContainer.clientWidth - LATERAL_SPREAD) / 2, // Start near center
          y: -Math.random() * 100 - 15, // Start above the screen, 15 is approx herb height
          vy: Math.random() * 1.5 + 0.5,  // Initial downward velocity (reduced for flutter)
          vx: (Math.random() - 0.5) * 1, // Initial horizontal velocity (reduced for flutter)
          rotation: Math.random() * 360,
          rotationSpeed: (Math.random() - 0.5) * 3, // Degrees per frame

          // Flutter properties
          flutterAmplitude: Math.random() * 2 + 1, // Max horizontal displacement for flutter
          flutterFrequency: (Math.random() * 0.05 + 0.02) / (Math.random()*0.5 + 0.5), // Oscillations per frame
          flutterPhase: Math.random() * Math.PI * 2, // Starting point in the sine wave

          landed: false,
          targetGatherX: animationContainer.clientWidth / 2, // Center of paper
          targetGatherY: GROUND_Y - 5, // Slightly above ground
          gathering: false,
          gathered: false,
          opacity: 0, // Start invisible
          appearDelay: Math.random() * 1500 // Staggered appearance, slightly longer window
        });
        herbElement.style.transform = `translate(${herbs[i].x}px, ${herbs[i].y}px) rotate(${herbs[i].rotation}deg)`;
        herbElement.style.position = 'absolute'; // Ensure absolute positioning is set
      }

      let frameCount = 0; // Used for flutter calculation
      let animationStartTime = null;

      function animateHerbs(timestamp) {
        if (!animationStartTime) animationStartTime = timestamp;
        const elapsedTime = timestamp - animationStartTime;
        frameCount++;

        herbs.forEach(herb => {
          if (herb.gathered) return;

          // Appearance
          if (!herb.opacity && elapsedTime > herb.appearDelay) {
            herb.opacity = 1;
            herb.element.style.opacity = 1;
          }
          if (!herb.opacity) return; // Don't animate if not yet appeared

          if (!herb.landed) {
            // Apply gravity
            herb.vy += GRAVITY;
            // Apply basic air resistance (drag)
            herb.vy *= (1 - DRAG_COEFFICIENT);
            herb.vx *= (1 - DRAG_COEFFICIENT); // Drag also affects base horizontal movement

            // Flutter calculation: sinusoidal horizontal movement
            // Modulate flutter effect: stronger at start, dampens as it falls/lands or based on vy
            const groundY = paperRect ? paperRect.top - animationContainer.getBoundingClientRect().top - herb.element.clientHeight/2 : animationContainer.clientHeight - herb.element.clientHeight;
            const paperLeft = paperRect ? paperRect.left - animationContainer.getBoundingClientRect().left : 0;
            const paperRight = paperRect ? paperRect.right - animationContainer.getBoundingClientRect().left : animationContainer.clientWidth;

            const currentFlutterAmplitude = herb.flutterAmplitude * Math.max(0, (1 - (Math.max(0, herb.y) / groundY)*0.7 ) ); // Dampen flutter
            const flutterOffset = Math.sin(herb.flutterPhase + frameCount * herb.flutterFrequency) * currentFlutterAmplitude;

            herb.y += herb.vy;
            herb.x += herb.vx + flutterOffset;
            herb.rotation += herb.rotationSpeed * Math.max(0.1, Math.abs(flutterOffset * 0.2));

            // Check for landing
            if (herb.y >= groundY) {
              herb.y = groundY;
              herb.vy *= -0.3; // Small bounce effect, or set to 0 to stop

              // Check horizontal boundaries
              if (herb.x < paperLeft || herb.x > paperRight) {
                // Herb missed the paper
                herb.vx = (Math.random() - 0.5) * 2; // Give it a slight push to continue falling off screen
                herb.vy = Math.random() * 1 + 0.5; // Fall downwards
                                herb.landed = false; // Not truly landed on paper
                                herb.targetGatherX = herb.x; // No specific gather point
                                herb.targetGatherY = groundY + 100; // fall below
                                if(elapsedTime > GATHER_HERBS_DELAY - 500) { // If close to gather time, just make it disappear
                                    herb.gathered = true; // effectively remove it
                                    herb.element.style.opacity = 0;
                                }
              } else {
                // Landed on paper
                herb.vx *= 0.5; // Dampen horizontal motion on landing
                herb.rotationSpeed = 0;
                herb.landed = true;
              }
               if (Math.abs(herb.vy) < 0.1 && herb.landed) herb.vy = 0; // Settle bounce

            }
          } else if (herb.gathering && !herb.gathered && herb.landed) { // Only gather if landed on paper
            // Move towards gather point
            const dx = herb.targetGatherX - herb.x;
            const dy = herb.targetGatherY - herb.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist < 5) { // Close enough
              herb.gathered = true;
              herb.element.style.opacity = 0; // Fade out when gathered
            } else {
              herb.x += dx * 0.1; // Move 10% of the distance per frame
              herb.y += dy * 0.1;
            }
          }
          herb.element.style.transform = `translate(${herb.x}px, ${herb.y}px) rotate(${herb.rotation}deg)`;
        });

        // Continue animation as long as not all herbs are gathered or if other animations are running
        if (herbs.some(h => !h.gathered) || elapsedTime < (GATHER_HERBS_DELAY + GATHER_HERBS_DURATION + 2000 /*buffer for other anims*/)) {
          requestAnimationFrame(animateHerbs);
        }
      }

      requestAnimationFrame(animateHerbs); // Start the herb animation loop

      // 2. Paper appears
      setTimeout(() => {
        paper.style.animation = `paperAppear ${PAPER_APPEAR_DURATION / 1000}s cubic-bezier(0.25, 0.1, 0.25, 1.5) forwards`;
        // After paper animation starts, get its dimensions for herb landing
        setTimeout(() => { // Allow time for paper to be somewhat visible
            paperRect = paper.getBoundingClientRect();
            // Adjust targetGatherX and targetGatherY based on actual paper position for herbs
            herbs.forEach(herb => {
                herb.targetGatherX = paperRect.width / 2;
                // targetGatherY needs to be relative to animationContainer, not absolute screen
                const containerTop = animationContainer.getBoundingClientRect().top;
                herb.targetGatherY = (paperRect.top - containerTop) + (paperRect.height / 2) - herb.element.clientHeight;
            });
        }, PAPER_APPEAR_DURATION * 0.5); // Get rect when paper is mostly visible
      }, PAPER_APPEAR_DELAY);

      // 3. Gather herbs (trigger gathering state for JS animation)
      setTimeout(() => {
        herbs.forEach(herb => {
          if (herb.landed) { // Only gather landed herbs
            herb.gathering = true;
          } else { // If not landed yet, mark as gathered to remove them
            herb.gathered = true;
            herb.element.style.opacity = 0;
          }
        });
      }, GATHER_HERBS_DELAY);

      // --- Tongue Lick Animation ---
      const tongueLickStartTime = GATHER_HERBS_DELAY + GATHER_HERBS_DURATION + 100; // Start shortly after herbs should be gathered
      setTimeout(() => {
        if (tongue && paperRect) {
          tongue.innerHTML = tongueSVGData;
          // Dynamically set the tongue's initial bottom position to be just above the paper.
          // The CSS animation handles the lick motion from this starting height.
          const paperTopVisual = paperRect.top - animationContainer.getBoundingClientRect().top;
          tongue.style.bottom = (animationContainer.clientHeight - paperTopVisual + 5) + 'px'; // Position slightly above paper's top edge.

          tongue.style.animation = `lickPaper ${TONGUE_LICK_ANIMATION_DURATION / 1000}s ease-in-out forwards`;
        }
      }, tongueLickStartTime);
      // --- End Tongue Lick Animation ---

      // 4. Roll joint (paper hides, joint appears with new SVG)
      // Adjusted to start after tongue lick animation completes
      const rollStartTime = tongueLickStartTime + TONGUE_LICK_ANIMATION_DURATION;
      setTimeout(() => {
        paper.style.animation = `rollJointPaperHide ${ROLL_JOINT_HIDE_DURATION / 1000}s ease-in forwards`;

        joint.innerHTML = jointSVGData; // Set the SVG content
        joint.style.animation = `rollJointAppear ${ROLL_JOINT_APPEAR_DURATION / 1000}s ease-out forwards`;
        joint.style.animationDelay = `${ROLL_JOINT_HIDE_DURATION * 0.25 / 1000}s`;
      }, rollStartTime);

      // 5. Joint flourish
      const flourishStartTime = rollStartTime + (ROLL_JOINT_HIDE_DURATION * 0.25) + ROLL_JOINT_APPEAR_DURATION;
      setTimeout(() => {
        // Using 'forwards' for rollJointAppear to ensure it holds its state, then adding flourish
        // The jointFlourish animation is set to alternate and repeat.
        joint.style.animation = `rollJointAppear ${ROLL_JOINT_APPEAR_DURATION / 1000}s ease-out forwards, jointFlourish ${JOINT_FLOURISH_DURATION / 1000}s cubic-bezier(0.68, -0.6, 0.32, 1.6) ${JOINT_FLOURISH_REPEATS} alternate forwards`;
        // The delay for jointFlourish is implicitly handled by its position in the animation string if rollJointAppear finishes first.
        // However, to be explicit and ensure rollJointAppear has finished, this timeout is set.
      }, flourishStartTime);


      // Total animation time before showing content
      // Calculated based on the sequence and overlaps, adding a final buffer
      const totalSimulatedLoadTime = flourishStartTime + (JOINT_FLOURISH_DURATION * JOINT_FLOURISH_REPEATS) + 400; // 400ms buffer

      setTimeout(() => {
        loader.style.display = 'none';
        content.style.display = 'block';
      }, totalSimulatedLoadTime);
    });
  </script>
</body>
</html>
