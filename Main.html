<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Loading Example Page</title>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      font-family: sans-serif;
      overflow: hidden; /* Prevent scrollbars during animation */
    }

    #loader {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: #f0f0f0; /* Light gray background */
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      flex-direction: column; /* Align items vertically for text + animation */
    }

    .loader-text {
      font-size: 1.5rem;
      font-weight: bold;
      color: #333;
      margin-bottom: 20px;
    }

    #animation-container {
      width: 200px;
      height: 150px;
      position: relative;
      /* border: 1px solid #ccc; */ /* For debugging */
    }

    .herb-svg-container { /* New container for SVG herbs */
      position: absolute;
      width: 15px; /* Adjust as needed based on SVG viewbox */
      height: 15px; /* Adjust as needed */
      opacity: 0;
      /* background-color: rgba(255,0,0,0.2); /* For debugging visibility */
    }

    .herb-svg-container svg {
      width: 100%;
      height: 100%;
      display: block;
    }

    #rolling-paper {
      position: absolute;
      width: 100px;
      height: 60px;
      background-color: white;
      border: 1px solid #ddd;
      bottom: 10px; /* Positioned at the bottom of the container */
      left: 50%;
      transform: translateX(-50%);
      opacity: 0;
      border-radius: 2px;
    }

    #joint {
      position: absolute;
      width: 80px; /* SVG viewBox width */
      height: 20px; /* SVG viewBox height */
      /* background-color: rgba(0,255,0,0.2); /* For debugging placement */
      /* border: none; Remove border if SVG is self-contained */
      bottom: 28px; /* Adjusted for new height and visual center */
      left: 50%;
      transform: translateX(-50%);
      opacity: 0;
      /* border-radius: 0; /* Not needed for SVG */
    }

    #joint svg { /* Ensure SVG scales within the container */
      width: 100%;
      height: 100%;
      display: block;
    }

    /* Animations */
    /* @keyframes fall is removed - will be handled by JavaScript */
    /* @keyframes gatherHerbs is removed - will be handled by JavaScript */

    @keyframes paperAppear {
      from { opacity: 0; transform: translateX(-50%) translateY(20px) scale(0.7); } /* Appear from slightly below and smaller */
      to { opacity: 1; transform: translateX(-50%) translateY(0px) scale(1); }
    }

    @keyframes rollJointPaperHide {
      0% {
        opacity: 1;
        width: 100px; /* Initial width of paper */
        height: 60px;
        transform: translateX(-50%) skewX(0deg);
        transform-origin: center;
      }
      50% {
        opacity: 0.7;
        width: 40px; /* Paper narrows significantly */
        height: 55px; /* Slight height reduction */
        transform: translateX(-25%) skewX(-15deg); /* Move to one side and skew */
        transform-origin: left center; /* Skew from left */
      }
      100% {
        opacity: 0;
        width: 10px; /* Almost disappears */
        height: 20px; /* Matches joint height for smoother transition */
        transform: translateX(0%) skewX(-30deg);
        transform-origin: left center;
      }
    }

    @keyframes rollJointAppear { /* Will be used for the SVG container */
      0% { opacity: 0; transform: translateX(-50%) scale(0.6) translateY(15px); } /* Start smaller, slightly lower, and scaled */
      100% { opacity: 1; transform: translateX(-50%) scale(1) translateY(0px); } /* Grow to final size and position */
    }

    @keyframes jointFlourish {
        0% { transform: translateX(-50%) translateY(0px) rotate(0deg); }
        30% { transform: translateX(-50%) translateY(-15px) rotate(-8deg); } /* Higher, more rotation */
        70% { transform: translateX(-50%) translateY(5px) rotate(3deg); } /* Overshoot downwards */
        100% { transform: translateX(-50%) translateY(0px) rotate(0deg); }
    }


    #content {
      display: none;
      padding: 2rem;
      text-align: center;
    }
  </style>
</head>
<body>

  <!-- Loader -->
  <div id="loader">
    <div class="loader-text">Preparing your experience...</div>
    <div id="animation-container">
      <!-- Herbs will be added here by JS -->
      <div id="rolling-paper"></div>
      <div id="joint"></div>
    </div>
  </div>

  <!-- Page Content -->
  <div id="content">
    <h1>Welcome to the Page!</h1>
    <p>This page was displayed after a simulated load delay.</p>
  </div>

  <script>
    window.addEventListener('load', () => {
      const loader = document.getElementById('loader');
      const content = document.getElementById('content');
      const animationContainer = document.getElementById('animation-container');
      const paper = document.getElementById('rolling-paper');
      const joint = document.getElementById('joint');

      // --- Asset Definitions ---
      const herbSVGData = [
        // Simple leaf shape 1
        '<svg viewBox="0 0 20 20"><path fill="#4CAF50" d="M10 0 C5 5, 5 15, 10 20 C15 15, 15 5, 10 0 Z"></path></svg>',
        // Simple leaf shape 2 (slightly different)
        '<svg viewBox="0 0 20 20"><path fill="#388E3C" d="M10 0 Q5 10, 10 20 Q15 10, 10 0 Z"></path></svg>',
        // Simple leaf shape 3 (more elongated)
        '<svg viewBox="0 0 20 20"><path fill="#558B2F" d="M10 0 C7 7, 7 13, 10 20 C13 13, 13 7, 10 0 Z"></path></svg>'
      ];

      const jointSVGData = `
        <svg viewBox="0 0 80 20">
          <!-- Main joint body (cone shape) -->
          <defs>
            <linearGradient id="jointGradient" x1="0%" y1="0%" x2="100%" y2="0%">
              <stop offset="0%" style="stop-color:#fdfdfd;stop-opacity:1" />
              <stop offset="15%" style="stop-color:#f8f8f8;stop-opacity:1" />
              <stop offset="85%" style="stop-color:#f0f0f0;stop-opacity:1" />
              <stop offset="100%" style="stop-color:#e8e8e8;stop-opacity:1" />
            </linearGradient>
            <filter id="slightShadow" x="-20%" y="-20%" width="140%" height="140%">
              <feGaussianBlur in="SourceAlpha" stdDeviation="0.5"/>
              <feOffset dx="0.5" dy="0.5" result="offsetblur"/>
              <feComponentTransfer>
                <feFuncA type="linear" slope="0.3"/>
              </feComponentTransfer>
              <feMerge>
                <feMergeNode/>
                <feMergeNode in="SourceGraphic"/>
              </feMerge>
            </filter>
          </defs>
          <path d="M0 2 Q5 0, 15 1 L65 5 Q75 7, 80 10 Q75 13, 65 15 L15 19 Q5 20, 0 18 Z" fill="url(#jointGradient)" filter="url(#slightShadow)" />
          <!-- Twist lines -->
          <path d="M10 2.5 Q20 4, 30 5.5 L32 14.5 Q22 16, 12 17.5 Z" fill="rgba(0,0,0,0.04)" />
          <path d="M35 5 Q45 6, 55 7 L57 13 Q47 14, 37 15 Z" fill="rgba(0,0,0,0.04)" />
          <path d="M60 6.5 Q65 7.5, 70 8.5 L71 11.5 Q66 12.5, 61 13.5 Z" fill="rgba(0,0,0,0.03)" />
          <!-- Filter end (optional, can be a different color or just implied) -->
          <path d="M0 2 Q3 2.5, 5 3 L5 17 Q3 17.5, 0 18 Z" fill="#E0C0A0" /> <!-- Light brown for filter -->
        </svg>
      `;

      // --- Animation Parameters ---
      const NUM_HERBS = 35; // Increased number of herbs as per new plan
      const PAPER_APPEAR_DELAY = 600; // ms - When paper starts to appear after load
      const PAPER_APPEAR_DURATION = 600; // ms
      const GATHER_HERBS_DELAY = 2200; // ms - Adjusted due to potentially longer fall times with flutter
      const GATHER_HERBS_DURATION = 1000; // ms - Slightly longer gather time
      const ROLL_JOINT_HIDE_DURATION = 700; // ms (paper hiding)
      const ROLL_JOINT_APPEAR_DURATION = 800; // ms (joint appearing)
      const JOINT_FLOURISH_DURATION = 600; //ms
      const JOINT_FLOURISH_REPEATS = 2;

      const herbs = []; // Array to store herb objects with their properties

      // Physics constants
      const GRAVITY = 0.08; // Acceleration due to gravity (pixels per frame^2)
      const DRAG_COEFFICIENT = 0.01; // Air resistance
      const GROUND_Y = animationContainer.clientHeight - 30; // Y-coordinate of the paper surface, adjusted for herb size
      const LATERAL_SPREAD = 180; // Max horizontal spread for falling herbs

      // 1. Create Herbs (as JS objects)
      for (let i = 0; i < NUM_HERBS; i++) {
        const herbElement = document.createElement('div');
        herbElement.classList.add('herb-svg-container');
        herbElement.innerHTML = herbSVGData[i % herbSVGData.length]; // Cycle through SVG shapes
        animationContainer.appendChild(herbElement);

        herbs.push({
          element: herbElement,
          x: Math.random() * LATERAL_SPREAD + (animationContainer.clientWidth - LATERAL_SPREAD) / 2, // Start near center
          y: -Math.random() * 100 - 15, // Start above the screen, 15 is approx herb height
          vy: Math.random() * 1.5 + 0.5,  // Initial downward velocity (reduced for flutter)
          vx: (Math.random() - 0.5) * 1, // Initial horizontal velocity (reduced for flutter)
          rotation: Math.random() * 360,
          rotationSpeed: (Math.random() - 0.5) * 3, // Degrees per frame

          // Flutter properties
          flutterAmplitude: Math.random() * 2 + 1, // Max horizontal displacement for flutter
          flutterFrequency: (Math.random() * 0.05 + 0.02) / (Math.random()*0.5 + 0.5), // Oscillations per frame
          flutterPhase: Math.random() * Math.PI * 2, // Starting point in the sine wave

          landed: false,
          targetGatherX: animationContainer.clientWidth / 2, // Center of paper
          targetGatherY: GROUND_Y - 5, // Slightly above ground
          gathering: false,
          gathered: false,
          opacity: 0, // Start invisible
          appearDelay: Math.random() * 1500 // Staggered appearance, slightly longer window
        });
        herbElement.style.transform = `translate(${herbs[i].x}px, ${herbs[i].y}px) rotate(${herbs[i].rotation}deg)`;
        herbElement.style.position = 'absolute'; // Ensure absolute positioning is set
      }

      let frameCount = 0; // Used for flutter calculation
      let animationStartTime = null;

      function animateHerbs(timestamp) {
        if (!animationStartTime) animationStartTime = timestamp;
        const elapsedTime = timestamp - animationStartTime;
        frameCount++;

        herbs.forEach(herb => {
          if (herb.gathered) return;

          // Appearance
          if (!herb.opacity && elapsedTime > herb.appearDelay) {
            herb.opacity = 1;
            herb.element.style.opacity = 1;
          }
          if (!herb.opacity) return; // Don't animate if not yet appeared

          if (!herb.landed) {
            // Apply gravity
            herb.vy += GRAVITY;
            // Apply basic air resistance (drag)
            herb.vy *= (1 - DRAG_COEFFICIENT);
            herb.vx *= (1 - DRAG_COEFFICIENT); // Drag also affects base horizontal movement

            // Flutter calculation: sinusoidal horizontal movement
            // Modulate flutter effect: stronger at start, dampens as it falls/lands or based on vy
            const currentFlutterAmplitude = herb.flutterAmplitude * Math.max(0, (1 - (herb.y / GROUND_Y)*0.7 ) ); // Dampen flutter as it nears ground
            const flutterOffset = Math.sin(herb.flutterPhase + frameCount * herb.flutterFrequency) * currentFlutterAmplitude;

            herb.y += herb.vy;
            herb.x += herb.vx + flutterOffset; // Base horizontal movement + flutter
            herb.rotation += herb.rotationSpeed * Math.max(0.1, Math.abs(flutterOffset * 0.2)); // Rotation influenced by flutter "strength"


            // Check for landing
            if (herb.y >= GROUND_Y) {
              herb.y = GROUND_Y;
              herb.vy = 0;
              herb.vx = 0;
              herb.rotationSpeed = 0;
              herb.landed = true;
            }
          } else if (herb.gathering && !herb.gathered) {
            // Move towards gather point
            const dx = herb.targetGatherX - herb.x;
            const dy = herb.targetGatherY - herb.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist < 5) { // Close enough
              herb.gathered = true;
              herb.element.style.opacity = 0; // Fade out when gathered
            } else {
              herb.x += dx * 0.1; // Move 10% of the distance per frame
              herb.y += dy * 0.1;
            }
          }
          herb.element.style.transform = `translate(${herb.x}px, ${herb.y}px) rotate(${herb.rotation}deg)`;
        });

        // Continue animation as long as not all herbs are gathered or if other animations are running
        if (herbs.some(h => !h.gathered) || elapsedTime < (GATHER_HERBS_DELAY + GATHER_HERBS_DURATION + 2000 /*buffer for other anims*/)) {
          requestAnimationFrame(animateHerbs);
        }
      }

      requestAnimationFrame(animateHerbs); // Start the herb animation loop

      // 2. Paper appears
      setTimeout(() => {
        paper.style.animation = `paperAppear ${PAPER_APPEAR_DURATION / 1000}s cubic-bezier(0.25, 0.1, 0.25, 1.5) forwards`;
      }, PAPER_APPEAR_DELAY);

      // 3. Gather herbs (trigger gathering state for JS animation)
      setTimeout(() => {
        herbs.forEach(herb => {
          if (herb.landed) { // Only gather landed herbs
            herb.gathering = true;
          } else { // If not landed yet, mark as gathered to remove them
            herb.gathered = true;
            herb.element.style.opacity = 0;
          }
        });
      }, GATHER_HERBS_DELAY);

      // 4. Roll joint (paper hides, joint appears with new SVG)
      const rollStartTime = GATHER_HERBS_DELAY + GATHER_HERBS_DURATION * 0.6; // Start rolling as herbs are still gathering
      setTimeout(() => {
        paper.style.animation = `rollJointPaperHide ${ROLL_JOINT_HIDE_DURATION / 1000}s ease-in forwards`;

        joint.innerHTML = jointSVGData; // Set the SVG content
        joint.style.animation = `rollJointAppear ${ROLL_JOINT_APPEAR_DURATION / 1000}s ease-out forwards`;
        // Joint appears slightly after paper starts to hide, creating an overlap for smoother transition
        joint.style.animationDelay = `${ROLL_JOINT_HIDE_DURATION * 0.25 / 1000}s`;

      }, rollStartTime);

      // 5. Joint flourish
      // Ensure flourish starts after the joint has fully appeared.
      const flourishStartTime = rollStartTime + ROLL_JOINT_HIDE_DURATION * 0.25 + ROLL_JOINT_APPEAR_DURATION;
      setTimeout(() => {
        // Using 'forwards' for rollJointAppear to ensure it holds its state, then adding flourish
        // The jointFlourish animation is set to alternate and repeat.
        joint.style.animation = `rollJointAppear ${ROLL_JOINT_APPEAR_DURATION / 1000}s ease-out forwards, jointFlourish ${JOINT_FLOURISH_DURATION / 1000}s cubic-bezier(0.68, -0.6, 0.32, 1.6) ${JOINT_FLOURISH_REPEATS} alternate forwards`;
        // The delay for jointFlourish is implicitly handled by its position in the animation string if rollJointAppear finishes first.
        // However, to be explicit and ensure rollJointAppear has finished, this timeout is set.
      }, flourishStartTime);


      // Total animation time before showing content
      // Calculated based on the sequence and overlaps, adding a final buffer
      const totalSimulatedLoadTime = flourishStartTime + (JOINT_FLOURISH_DURATION * JOINT_FLOURISH_REPEATS) + 400; // 400ms buffer

      setTimeout(() => {
        loader.style.display = 'none';
        content.style.display = 'block';
      }, totalSimulatedLoadTime);
    });
  </script>
</body>
</html>
